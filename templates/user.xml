<templateSet group="user">
  <template name="pt.dao" value="class Student {&#10;    private java.lang.String name;&#10;    private int rollNo;&#10;&#10;    Student(java.lang.String name, int rollNo){&#10;        this.name = name;&#10;        this.rollNo = rollNo;&#10;    }&#10;&#10;    public java.lang.String getName() {&#10;        return name;&#10;    }&#10;&#10;    public void setName(java.lang.String name) {&#10;        this.name = name;&#10;    }&#10;&#10;    public int getRollNo() {&#10;        return rollNo;&#10;    }&#10;&#10;    public void setRollNo(int rollNo) {&#10;        this.rollNo = rollNo;&#10;    }&#10;}&#10;&#10;interface StudentDao {&#10;    public java.util.List&lt;Student&gt; getAllStudents();&#10;    public Student getStudent(int rollNo);&#10;    public void updateStudent(Student student);&#10;    public void deleteStudent(Student student);&#10;}&#10;&#10;class StudentDaoImpl implements StudentDao {&#10;&#10;    //list is working as a database&#10;    java.util.List&lt;Student&gt; students;&#10;&#10;    public StudentDaoImpl(){&#10;        students = new java.util.ArrayList&lt;Student&gt;();&#10;        Student student1 = new Student(&quot;Robert&quot;,0);&#10;        Student student2 = new Student(&quot;John&quot;,1);&#10;        students.add(student1);&#10;        students.add(student2);&#10;    }&#10;    @java.lang.Override&#10;    public void deleteStudent(Student student) {&#10;        students.remove(student.getRollNo());&#10;        java.lang.System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() + &quot;, deleted from database&quot;);&#10;    }&#10;&#10;    //retrive list of students from the database&#10;    @java.lang.Override&#10;    public java.util.List&lt;Student&gt; getAllStudents() {&#10;        return students;&#10;    }&#10;&#10;    @java.lang.Override&#10;    public Student getStudent(int rollNo) {&#10;        return students.get(rollNo);&#10;    }&#10;&#10;    @java.lang.Override&#10;    public void updateStudent(Student student) {&#10;        students.get(student.getRollNo()).setName(student.getName());&#10;        java.lang.System.out.println(&quot;Student: Roll No &quot; + student.getRollNo() + &quot;, updated in the database&quot;);&#10;    }&#10;}&#10;&#10;class DaoPatternDemo {&#10;    public static void main(java.lang.String[] args) {&#10;        StudentDao studentDao = new StudentDaoImpl();&#10;&#10;        //print all students&#10;        for (Student student : studentDao.getAllStudents()) {&#10;            java.lang.System.out.println(&quot;Student: [RollNo : &quot; + student.getRollNo() + &quot;, Name : &quot; + student.getName() + &quot; ]&quot;);&#10;        }&#10;&#10;&#10;        //update student&#10;        Student student =studentDao.getAllStudents().get(0);&#10;        student.setName(&quot;Michael&quot;);&#10;        studentDao.updateStudent(student);&#10;&#10;        //get the student&#10;        studentDao.getStudent(0);&#10;        java.lang.System.out.println(&quot;Student: [RollNo : &quot; + student.getRollNo() + &quot;, Name : &quot; + student.getName() + &quot; ]&quot;);&#10;    }&#10;}" description="Simple DAO pattern" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="dkc.java.postgres.mongo.maven" value="version: '3'&#10;services:&#10;&#10;  ade-postgres:&#10;    image: &quot;postgres&quot;&#10;    container_name: &quot;my_postgres&quot;&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    restart: always&#10;&#10;  ade-mongo:&#10;    container_name: mongo&#10;    image: mongo&#10;    ports:&#10;      - &quot;27017:27017&quot;&#10;    restart: always&#10;&#10;&#10;  app:&#10;    build: .&#10;    volumes:&#10;      - .:/app&#10;      - ~/.m2:/root/.m2&#10;    working_dir: /app&#10;    ports:&#10;      - 8080:8080&#10;    command: mvn clean spring-boot:run&#10;    depends_on:&#10;      - ade-postgres&#10;      - ade-mongo" description="Simple docker compose file for java, postgres, mongo and maven" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="dk.maven" value="FROM maven:3.6.1-jdk-12" description="Simple dockerfile for maven" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="dk.gradle" value="FROM gradle:5.5.1-jdk12" description="Simple dockerfile for gradle" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="sb.setup.postgres" value="## default connection pool&#10;spring.datasource.hikari.connectionTimeout=20000&#10;spring.datasource.hikari.maximumPoolSize=5&#10;spring.datasource.url=jdbc:postgresql://ade-postgres:5432/postgres&#10;spring.datasource.username=postgres&#10;spring.datasource.password=&#10;spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true&#10;spring.jpa.hibernate.ddl-auto=create" description="Spring Boot Postgres setup" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="sb.setup.mongo" value="spring.data.mongodb.host=ade-mongo&#10;spring.data.mongodb.port=27017&#10;spring.data.mongodb.database=demo&#10;#spring.data.mongodb.uri=mongodb://eyeco:eyeco2019@ds249137.mlab.com:49137/eyeco" description="Spring Boot Mongo setup" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="dkc.java.postgres.gradle" value="version: '3'&#10;services:&#10;&#10;  ade-postgres:&#10;    image: &quot;postgres&quot;&#10;    container_name: &quot;my_postgres&quot;&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    restart: always&#10;&#10;  app:&#10;    build: .&#10;    volumes:&#10;      - .:/app&#10;      - ~/.m2:/root/.m2&#10;    working_dir: /app&#10;    ports:&#10;      - 8080:8080&#10;    command: ./gradlew clean bootRun&#10;    depends_on:&#10;      - ade-postgres" description="Simple docker compose file for java, postgres and gradle" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="gdl.swagger" value="compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2'&#10;compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2'" description="Gradle Swager dependencies" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY_EXPRESSION" value="true" />
      <option name="GROOVY_STATEMENT" value="true" />
    </context>
  </template>
  <template name="sb.setup.pagination" value="spring.data.web.pageable.one-indexed-parameters=true" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="sb.starter.api" value="import lombok.Data;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.hibernate.annotations.CreationTimestamp;&#10;import org.hibernate.annotations.UpdateTimestamp;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.stereotype.Repository;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import javax.persistence.Entity;&#10;import javax.persistence.GeneratedValue;&#10;import javax.persistence.GenerationType;&#10;import javax.persistence.Id;&#10;import javax.validation.Valid;&#10;import javax.validation.constraints.NotNull;&#10;import java.math.BigDecimal;&#10;import java.util.Date;&#10;import java.util.Optional;&#10;&#10;&#10;// model&#10;@Data&#10;@Entity&#10;class Product {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @NotNull(message = &quot;it can be null&quot;)&#10;    private String name;&#10;&#10;    private String description;&#10;&#10;    private BigDecimal price;&#10;&#10;    @CreationTimestamp&#10;    private Date createdAt;&#10;&#10;    @UpdateTimestamp&#10;    private Date updatedAt;&#10;}&#10;&#10;// dto&#10;&#10;&#10;// interface&#10;interface ProductService {&#10;    public Product save(Product product);&#10;&#10;    public Page&lt;Product&gt; findAll(Pageable pageable);&#10;&#10;    public Optional&lt;Product&gt; findById(Long id);&#10;&#10;    public void deleteById(Long id);&#10;}&#10;&#10;// repository&#10;@Repository&#10;interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {&#10;}&#10;&#10;&#10;// implementation&#10;@RequiredArgsConstructor&#10;@Service&#10;class ProductServiceImpl implements ProductService {&#10;&#10;    private final ProductRepository productRespository;&#10;&#10;    public Page&lt;Product&gt; findAll(Pageable pageable) {&#10;        return productRespository.findAll(pageable);&#10;    }&#10;&#10;    public Optional&lt;Product&gt; findById(Long id) {&#10;        return productRespository.findById(id);&#10;    }&#10;&#10;    public Product save(Product product) {&#10;        return productRespository.save(product);&#10;    }&#10;&#10;    public void deleteById(Long id) {&#10;        productRespository.deleteById(id);&#10;    }&#10;}&#10;&#10;// endpoints&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/products&quot;)&#10;@CrossOrigin&#10;class ProductAPI {&#10;    private final ProductService productService;&#10;&#10;    @GetMapping&#10;    public Page&lt;Product&gt; findAll(Pageable pageable) {&#10;        return productService.findAll(pageable);&#10;    }&#10;&#10;    @PostMapping&#10;    public Product create(@RequestBody @Valid Product product) {&#10;        return productService.save(product);&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    public Product findById(@PathVariable Long id) {&#10;        return productService.findById(id).orElseThrow(() -&gt; new RuntimeException(&quot;resource not found&quot;));&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    public Product update(@PathVariable Long id, @RequestBody Product product) {&#10;        product.setId(id);&#10;        return productService.save(product);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    public void delete(@PathVariable Long id) {&#10;        productService.deleteById(id);&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;// app&#10;@SpringBootApplication&#10;//@EnableSwagger2&#10;public class DemoApiApplication {&#10;&#10;    //http://localhost:8080/swagger-ui.html&#10;&#9;/*@Bean&#10;&#9;public Docket swagger() {&#10;&#9;&#9;return new Docket(DocumentationType.SWAGGER_2)&#10;&#9;&#9;&#9;&#9;.select()&#10;&#9;&#9;&#9;&#9;.apis(RequestHandlerSelectors.any())&#10;&#9;&#9;&#9;&#9;.paths(PathSelectors.any())&#10;&#9;&#9;&#9;&#9;.build();&#10;&#9;}*/&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(DemoApiApplication.class, args);&#10;    }&#10;&#10;}&#10;" description="Simple Spring Boot API" toReformat="false" toShortenFQNames="false">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="sb.starter.exception" value="@Getter&#10;@Setter&#10;class ApiError {&#10;&#10;    private HttpStatus status;&#10;    private String message;&#10;    private List&lt;String&gt; errors;&#10;&#10;    public ApiError(HttpStatus status, String message, List&lt;String&gt; errors) {&#10;        super();&#10;        this.status = status;&#10;        this.message = message;&#10;        this.errors = errors;&#10;    }&#10;&#10;    public ApiError(HttpStatus status, String message, String error) {&#10;        super();&#10;        this.status = status;&#10;        this.message = message;&#10;        errors = Arrays.asList(error);&#10;    }&#10;&#10;}&#10;&#10;&#10;@ControllerAdvice&#10;class MyExceptionHandler extends ResponseEntityExceptionHandler {&#10;&#10;   /* @ExceptionHandler({ Exception.class })&#10;    public ResponseEntity&lt;Object&gt; handleAll(Exception ex, WebRequest request) {&#10;        ApiError apiError = new ApiError(&#10;                HttpStatus.INTERNAL_SERVER_ERROR, ex.getLocalizedMessage(), &quot;error occurred&quot;);&#10;        return new ResponseEntity&lt;&gt;(&#10;                apiError, new HttpHeaders(), apiError.getStatus());&#10;    }*/&#10;&#10;   /* @ExceptionHandler({ ConstraintViolationException.class })&#10;    public ResponseEntity&lt;Object&gt; handleConstraintViolation(&#10;            ConstraintViolationException ex, WebRequest request) {&#10;        List&lt;String&gt; errors = new ArrayList&lt;String&gt;();&#10;        for (ConstraintViolation&lt;?&gt; violation : ex.getConstraintViolations()) {&#10;            errors.add(violation.getRootBeanClass().getName() + &quot; &quot; +&#10;                    violation.getPropertyPath() + &quot;: &quot; + violation.getMessage());&#10;        }&#10;&#10;        ApiError apiError =&#10;                new ApiError(HttpStatus.BAD_REQUEST, ex.getLocalizedMessage(), errors);&#10;        return new ResponseEntity&lt;&gt;(&#10;                apiError, new HttpHeaders(), apiError.getStatus());&#10;    }*/&#10;&#10;&#10;    @Override&#10;    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(&#10;            MethodArgumentNotValidException ex,&#10;            HttpHeaders headers,&#10;            HttpStatus status,&#10;            WebRequest request) {&#10;        List&lt;String&gt; errors = new ArrayList&lt;String&gt;();&#10;        for (FieldError error : ex.getBindingResult().getFieldErrors()) {&#10;            errors.add(error.getField() + &quot;: &quot; + error.getDefaultMessage());&#10;        }&#10;        for (ObjectError error : ex.getBindingResult().getGlobalErrors()) {&#10;            errors.add(error.getObjectName() + &quot;: &quot; + error.getDefaultMessage());&#10;        }&#10;&#10;        ApiError apiError =&#10;                new ApiError(HttpStatus.BAD_REQUEST, ex.getLocalizedMessage(), errors);&#10;        return handleExceptionInternal(&#10;                ex, apiError, headers, apiError.getStatus(), request);&#10;    }&#10;&#10;&#10;   /* @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public Map&lt;String, String&gt; handleValidationExceptions(&#10;            MethodArgumentNotValidException ex) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        ex.getBindingResult().getAllErrors().forEach((error) -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;        return errors;&#10;    }*/&#10;&#10;   /*&#10;&#10;   {&#10;  &quot;name&quot;:&quot;Name is mandatory&quot;,&#10;  &quot;email&quot;:&quot;Email is mandatory&quot;&#10;}&#10;&#10;    */&#10;&#10;&#10;}" description="" toReformat="false" toShortenFQNames="false">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
  <template name="gdl.jwt" value="compile group: 'io.jsonwebtoken', name: 'jjwt', version: '0.9.1'" description="Jwt dependencie" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY_EXPRESSION" value="true" />
      <option name="GROOVY_STATEMENT" value="true" />
    </context>
  </template>
  <template name="sb.setup.jwt" value="app.jwtSecret= JWTSuperSecretKey&#10;app.jwtExpirationInMs = 604800000" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="GROOVY" value="false" />
      <option name="HTML" value="false" />
      <option name="JAVA_CODE" value="false" />
      <option name="JSON" value="false" />
      <option name="KOTLIN" value="false" />
      <option name="MAVEN" value="false" />
      <option name="OTHER" value="true" />
      <option name="XML" value="false" />
    </context>
  </template>
  <template name="sb.starter.jwt" value="import com.fasterxml.jackson.annotation.JsonIgnore;&#10;import io.jsonwebtoken.Claims;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.SignatureAlgorithm;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.hibernate.annotations.NaturalId;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.boot.CommandLineRunner;&#10;import org.springframework.boot.SpringApplication;&#10;import org.springframework.boot.autoconfigure.SpringBootApplication;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.config.BeanIds;&#10;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;&#10;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.core.GrantedAuthority;&#10;import org.springframework.security.core.annotation.AuthenticationPrincipal;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.context.SecurityContextHolder;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;import org.springframework.security.core.userdetails.UserDetailsService;&#10;import org.springframework.security.core.userdetails.UsernameNotFoundException;&#10;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.stereotype.Repository;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;&#10;import javax.persistence.*;&#10;import javax.servlet.FilterChain;&#10;import javax.servlet.ServletException;&#10;import javax.servlet.http.HttpServletRequest;&#10;import javax.servlet.http.HttpServletResponse;&#10;import javax.validation.Valid;&#10;import javax.validation.constraints.Email;&#10;import java.io.IOException;&#10;import java.util.*;&#10;&#10;import static java.util.stream.Collectors.toList;&#10;&#10;enum RoleName {&#10;    ROLE_USER,&#10;    ROLE_ADMIN&#10;}&#10;&#10;@Entity&#10;@Table(name = &quot;roles&quot;)&#10;@Data&#10;@NoArgsConstructor&#10;class Role {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    @Enumerated(EnumType.STRING)&#10;    @NaturalId&#10;    @Column(length = 60)&#10;    private RoleName name;&#10;&#10;    public Role(RoleName name) {&#10;        this.name = name;&#10;    }&#10;&#10;&#10;}&#10;&#10;@Data&#10;@Entity&#10;class User {&#10;    @Id&#10;    @GeneratedValue(strategy = GenerationType.IDENTITY)&#10;    private Long id;&#10;&#10;    private String name;&#10;&#10;    @Column(unique = true)&#10;    private String username;&#10;&#10;    @Email&#10;    @Column(unique = true)&#10;    private String email;&#10;&#10;    private String password;&#10;&#10;    @ManyToMany(fetch = FetchType.LAZY)&#10;    @JoinTable(name = &quot;user_roles&quot;,&#10;            joinColumns = @JoinColumn(name = &quot;user_id&quot;),&#10;            inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;))&#10;    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#10;&#10;&#10;    public User(String name, String username, String email, String password) {&#10;        this.name = name;&#10;        this.username = username;&#10;        this.email = email;&#10;        this.password = password;&#10;    }&#10;&#10;&#10;}&#10;&#10;class UserPrincipal implements UserDetails {&#10;    private Long id;&#10;&#10;    private String name;&#10;&#10;    private String username;&#10;&#10;    @JsonIgnore&#10;    private String email;&#10;&#10;    @JsonIgnore&#10;    private String password;&#10;&#10;    private Collection&lt;? extends GrantedAuthority&gt; authorities;&#10;&#10;    public UserPrincipal(Long id, String name, String username, String email, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) {&#10;        this.id = id;&#10;        this.name = name;&#10;        this.username = username;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.authorities = authorities;&#10;    }&#10;&#10;    public static UserPrincipal create(User user) {&#10;        List&lt;GrantedAuthority&gt; authorities = user.getRoles().stream().map(role -&gt;&#10;                new SimpleGrantedAuthority(role.getName().name())&#10;        ).collect(toList());&#10;&#10;        return new UserPrincipal(&#10;                user.getId(),&#10;                user.getName(),&#10;                user.getUsername(),&#10;                user.getEmail(),&#10;                user.getPassword(),&#10;                authorities&#10;        );&#10;    }&#10;&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    public String getEmail() {&#10;        return email;&#10;    }&#10;&#10;    @Override&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    @Override&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    @Override&#10;    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {&#10;        return authorities;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonLocked() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isCredentialsNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isEnabled() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (o == null || getClass() != o.getClass()) return false;&#10;        UserPrincipal that = (UserPrincipal) o;&#10;        return Objects.equals(id, that.id);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;&#10;        return Objects.hash(id);&#10;    }&#10;}&#10;&#10;@Repository&#10;interface RoleRepository extends JpaRepository&lt;Role, Long&gt; {&#10;    Optional&lt;Role&gt; findByName(RoleName roleName);&#10;}&#10;&#10;@Repository&#10;interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    Optional&lt;User&gt; findByUsernameOrEmail(String username, String email);&#10;}&#10;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;class CustomUserDetailsService implements UserDetailsService {&#10;&#10;    private final UserRepository userRepository;&#10;&#10;    @Override&#10;    @Transactional&#10;    public UserDetails loadUserByUsername(String usernameOrEmail)&#10;            throws UsernameNotFoundException {&#10;        // Let people login with either username or email&#10;        User user = userRepository.findByUsernameOrEmail(usernameOrEmail, usernameOrEmail)&#10;                .orElseThrow(() -&gt;&#10;                        new RuntimeException(&quot;User not found with username or email : &quot; + usernameOrEmail)&#10;                );&#10;&#10;        return UserPrincipal.create(user);&#10;&#10;    }&#10;&#10;    // This method is used by JWTAuthenticationFilter&#10;    @Transactional&#10;    public UserDetails loadUserById(Long id) {&#10;        User user = userRepository.findById(id).orElseThrow(&#10;                () -&gt; new RuntimeException(&quot;User not found with id : &quot; + id)&#10;        );&#10;&#10;        return UserPrincipal.create(user);&#10;&#10;&#10;    }&#10;}&#10;&#10;&#10;@Component&#10;@Slf4j&#10;class JwtTokenProvider {&#10;&#10;    @Value(&quot;${app.jwtSecret}&quot;)&#10;    private String jwtSecret = &quot;JWTSUperSecretKey&quot;;&#10;&#10;    @Value(&quot;${app.jwtExpirationInMs}&quot;)&#10;    private int jwtExpirationInMs;&#10;&#10;    public String generateToken(Authentication authentication) {&#10;&#10;        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();&#10;        Date now = new Date();&#10;        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);&#10;&#10;        return Jwts.builder()&#10;                .setSubject(Long.toString(userPrincipal.getId()))&#10;                .setIssuedAt(new Date())&#10;                .setExpiration(expiryDate)&#10;                .signWith(SignatureAlgorithm.HS512, jwtSecret)&#10;                .compact();&#10;    }&#10;&#10;    public Long getUserIdFromJWT(String token) {&#10;        Claims claims = Jwts.parser()&#10;                .setSigningKey(jwtSecret)&#10;                .parseClaimsJws(token)&#10;                .getBody();&#10;&#10;        return Long.parseLong(claims.getSubject());&#10;    }&#10;&#10;    public boolean validateToken(String authToken) {&#10;        try {&#10;            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);&#10;            return true;&#10;        } catch (Exception ex) {&#10;            log.error(ex.getMessage());&#10;        }&#10;        return false;&#10;    }&#10;}&#10;&#10;&#10;@Slf4j&#10;class JwtAuthenticationFilter extends OncePerRequestFilter {&#10;&#10;    @Autowired&#10;    private JwtTokenProvider tokenProvider;&#10;&#10;    @Autowired&#10;    private CustomUserDetailsService customUserDetailsService;&#10;&#10;    @Override&#10;    protected void doFilterInternal(HttpServletRequest request,&#10;                                    HttpServletResponse response,&#10;                                    FilterChain filterChain) throws ServletException, IOException {&#10;        try {&#10;            String jwt = getJwtFromRequest(request);&#10;&#10;            if (StringUtils.hasText(jwt) &amp;&amp; tokenProvider.validateToken(jwt)) {&#10;                Long userId = tokenProvider.getUserIdFromJWT(jwt);&#10;&#10;                UserDetails userDetails = customUserDetailsService.loadUserById(userId);&#10;                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());&#10;                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));&#10;&#10;                SecurityContextHolder.getContext().setAuthentication(authentication);&#10;            }&#10;        } catch (Exception ex) {&#10;            log.error(&quot;Could not set user authentication in security context&quot;, ex);&#10;        }&#10;&#10;        filterChain.doFilter(request, response);&#10;    }&#10;&#10;    private String getJwtFromRequest(HttpServletRequest request) {&#10;        String bearerToken = request.getHeader(&quot;Authorization&quot;);&#10;        if (StringUtils.hasText(bearerToken) &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {&#10;            return bearerToken.substring(7, bearerToken.length());&#10;        }&#10;        return null;&#10;    }&#10;}&#10;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;@EnableGlobalMethodSecurity(prePostEnabled = true)&#10;class SecurityConfig extends WebSecurityConfigurerAdapter {&#10;    @Autowired&#10;    CustomUserDetailsService customUserDetailsService;&#10;&#10;&#10;    @Bean&#10;    public JwtAuthenticationFilter jwtAuthenticationFilter() {&#10;        return new JwtAuthenticationFilter();&#10;    }&#10;&#10;    @Override&#10;    public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {&#10;        authenticationManagerBuilder&#10;                .userDetailsService(customUserDetailsService)&#10;                .passwordEncoder(passwordEncoder());&#10;    }&#10;&#10;    @Bean(BeanIds.AUTHENTICATION_MANAGER)&#10;    @Override&#10;    public AuthenticationManager authenticationManagerBean() throws Exception {&#10;        return super.authenticationManagerBean();&#10;    }&#10;&#10;    @Bean&#10;    public PasswordEncoder passwordEncoder() {&#10;        return new BCryptPasswordEncoder();&#10;    }&#10;&#10;    @Override&#10;    protected void configure(HttpSecurity http) throws Exception {&#10;        http&#10;                .cors()&#10;                .and()&#10;                .csrf()&#10;                .disable()&#10;                .exceptionHandling()&#10;                .and()&#10;                .sessionManagement()&#10;                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;                .and()&#10;                .authorizeRequests()&#10;                .antMatchers(&quot;/api/signup&quot;, &quot;/api/signin&quot;)&#10;                .permitAll()&#10;                .anyRequest()&#10;                .authenticated();&#10;&#10;        // Add our custom JWT security filter&#10;        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);&#10;&#10;    }&#10;}&#10;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api&quot;)&#10;@RequiredArgsConstructor&#10;class Endpoints {&#10;&#10;    private final AuthenticationManager authenticationManager;&#10;&#10;    private final UserRepository userRepository;&#10;&#10;    private final RoleRepository roleRepository;&#10;&#10;    private final PasswordEncoder passwordEncoder;&#10;&#10;    private final JwtTokenProvider tokenProvider;&#10;&#10;    @GetMapping&#10;    @PreAuthorize(&quot;hasRole('USER')&quot;)&#10;    public String index() {&#10;        return &quot;index endpoint&quot;;&#10;    }&#10;&#10;    @GetMapping(&quot;/me&quot;)&#10;    @PreAuthorize(&quot;hasRole('USER')&quot;)&#10;    public Map&lt;Object, Object&gt; currentUser(@AuthenticationPrincipal UserDetails userDetails) {&#10;        Map&lt;Object, Object&gt; model = new HashMap&lt;&gt;();&#10;        model.put(&quot;username&quot;, userDetails.getUsername());&#10;        model.put(&quot;roles&quot;, userDetails.getAuthorities()&#10;                .stream()&#10;                .map(GrantedAuthority::getAuthority)&#10;                .collect(toList())&#10;        );&#10;        return model;&#10;    }&#10;&#10;    @PostMapping(&quot;/signin&quot;)&#10;    public String signin(@Valid @RequestBody User user) {&#10;&#10;        Authentication authentication = authenticationManager.authenticate(&#10;                new UsernamePasswordAuthenticationToken(&#10;                        user.getEmail(),&#10;                        user.getPassword()&#10;                )&#10;        );&#10;&#10;        SecurityContextHolder.getContext().setAuthentication(authentication);&#10;&#10;        return tokenProvider.generateToken(authentication);&#10;&#10;    }&#10;&#10;    @PostMapping(&quot;/signup&quot;)&#10;    public String signup(@Valid @RequestBody User userRequest) {&#10;&#10;        // Creating user's account&#10;        User user = new User(userRequest.getName(), userRequest.getUsername(),&#10;                userRequest.getEmail(), userRequest.getPassword());&#10;&#10;        user.setPassword(passwordEncoder.encode(user.getPassword()));&#10;&#10;        Role userRole = roleRepository.findByName(RoleName.ROLE_USER)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Role Unavailable&quot;));&#10;&#10;        user.setRoles(Collections.singleton(userRole));&#10;&#10;        userRepository.save(user);&#10;        return &quot;User registered successfully&quot;;&#10;&#10;&#10;    }&#10;&#10;    @GetMapping(&quot;/admin&quot;)&#10;    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;    public String admin() {&#10;        return &quot;admin point&quot;;&#10;    }&#10;&#10;&#10;}&#10;&#10;&#10;@SpringBootApplication&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class DemoJwtApplication implements CommandLineRunner {&#10;&#10;    private final RoleRepository roleRepository;&#10;&#10;    @Override&#10;    public void run(String... args) {&#10;        log.info(&quot;initializing roles data...&quot;);&#10;        Arrays.asList(RoleName.ROLE_ADMIN, RoleName.ROLE_USER).forEach(r -&gt; this.roleRepository.save(new Role(r)));&#10;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(DemoJwtApplication.class, args);&#10;    }&#10;&#10;}" description="" toReformat="false" toShortenFQNames="false">
    <context>
      <option name="JAVA_DECLARATION" value="true" />
    </context>
  </template>
</templateSet>